//  metrics.js
//
//  library focused on providing a metrics API
//  for the Gulp itself, and all the plugins/modules within it
//
module.exports = function(gulpInst) {

console.log('starting metrics.js');

'use strict';

//--------------------
//  modules
var fs        = require('fs'),
    path      = require('path'),
    // vfs       = require('vinyl-fs'),
//--------------------
//  Constants
    DEFAULT_DEST_PATH = path.join( __dirname, '../metrics'), //  ??????
//--------------------
//  variables
    metrics,
    Session,
    EventList,
    metricEvent,
    events = [],
    buffer = {},
    timeZero = process.hrtime(),  //  timeZero for our lib ( when the lib was instantiated )
    fs_readFile,
    fs_writeFile,
    fs_createWriteStream,
    gulp_src,
    gulp_dest,
    idThis;
//--------------------

console.log('cwd', __dirname);
console.log('gulpInstance', gulpInst);
console.log('metrics.json path :', DEFAULT_DEST_PATH);

//------------------ fs ------------------
//  monkeypatch fs read and write file in
//  order to log metrics from them
//
//  keep references to the original functions
fs_readFile = fs.readFile;
fs_writeFile = fs.writeFile;
fs_createWriteStream = fs.createWriteStream;
gulp_src = gulpInst.src;
gulp_dest = gulpInst.dest;

//  hijack readFile
fs.readFile = function(filename, options, callback){

  var start,
      onDone;

  //  set the start time
  start = process.hrtime();

  onDone = function(){

    //  set the end time
    var end = process.hrtime();

    // //  add the event in the metrics
    // metrics.addEvent({
    //   filename: filename,
    //   name: filename,
    //   type: 'fileRead',
    //   start: start,
    //   end: end
    // });
  };

  if(callback === undefined){

    fs_readFile(filename, function(err, data){
      onDone();

      if(typeof options === 'function') {
        options.call(this, err, data);
      }
    });

  } else {

    fs_readFile(filename, options, function(err, data){

      onDone();
      callback.call(this, err, data);
    });
  }

};

fs.writeFile = function(filename, data, options, callback){

  var start,
      onDone;

  //  set the start time
  start = process.hrtime();

  console.log('fs.writeFile', start);

  onDone = function(){

    //  set the end time
    var end = process.hrtime();

    // //  add the event in the metrics
    // metrics.addEvent({
    //   filename: filename,
    //   name: filename,
    //   type: 'fileWrite',
    //   start: start,
    //   end: end
    // });
  };

  if(callback === undefined){

    fs_writeFile(filename, data, function(err){
      onDone();
      if(typeof options === 'function') {
        options.call(this, err);
      }
    });
  } else {

    fs_writeFile(filename, data, options, function(err){

      onDone();
      callback.call(this, err);
    });
  }
};

fs.createWriteStream = function(path, options){

  console.log('fs.createWriteStream', path);

  return fs_createWriteStream.call(this, path, options);
};

//------------------ vfs ------------------
gulpInst.src = function(globs, options){

  //  set up a counter for identifying calls to this function
  if(gulpInst.src.counter === undefined){
    gulpInst.src.counter = 0;
  }

  var gulp_src_stream = gulp_src(globs, options),
      id = 'gulp_src.' + gulpInst.src.counter;

  //  increment the counter
  gulpInst.src.counter += 1;

  gulp_src_stream
  .on('data', function(file){
    console.log('file.path', path.basename(file.path) )
  })
  .on('end', function(){
    console.log('end for globs', globs);
  });

  console.log('gulp_src', id, globs);

  return gulp_src_stream;
};

gulpInst.dest = function(globs, options){

  console.log('gulp_dest', globs);
  var gulp_dest_stream = gulp_dest(globs, options);

  gulp_dest_stream
  .on('data', function(file){
    console.log('file.path', path.basename(file.path) )
  })
  .on('end', function(){
    console.log('end for globs', globs);
  });

  return gulp_dest_stream;
};

//------------------ end of monkeypatching ------------------

//  listen for task start/end events
gulpInst.on('task_start', function (e) {
  console.log('task_start',e.task, e.message);
});

gulpInst.on('task_stop', function (e) {
  console.log('task_stop',e.task, e.message);
});

console.log('=========================== timeZero',timeZero);

idThis = function(ev){

  //  produce a unique id for this event
  return ev.type + '.' + ev.name + '.' + ev.start[0] + '-' + ev.start[1];
};

//------------------ metrics API ------------------
//
//  constructor of a Session object
//  holds a gulp session which should be a parent task run
Session = function(){

  // mark start time
  this.startTime = process.hrtime();

  this.end = function(){
    //  mark finish time
    this.finishTime = process.hrtime();
  }

  this.exportSession = function(){

  }

  return this;
};

EventList = function(){
  this.list = {};
  this.counter = 0;  //  set seed

  return this;
};

EventList.prototype.getSeed = function(){
  return this.counter += 1;
};

EventList.prototype.addEvent = function(ev){

  //  event should have:
  //  name 'string'
  //  type 'string'
  //  filePath 'string'

  ev.startTime = process.hrtime();

  ev.id = this.getSeed();

  this.list[ev.id] = ev;

  return this;
};

EventList.prototype.getList = function(){
  return this.list;
};

/*
  //  clear all the events in the metrics
  clearEvents: function(){

    events = [];
  },
  // taskStart: function(taskName){

  //   if(buffer[taskName] !== undefined){
  //     throw Error('task '+ taskName + ' already exists!');
  //   }

  //   buffer[taskName] = {
  //     start: process.hrtime()
  //   };
  // },
  // taskEnd: function(taskName){

  //   if(buffer[taskName] === undefined){
  //     throw Error('task '+ taskName + ' has not started!');
  //   }

  //   buffer[taskName].end = process.hrtime();

  //   events.push({
  //     name: taskName,
  //     type: 'task',
  //     start: buffer[taskName].start,
  //     end: buffer[taskName].end
  //   });

  //   buffer[taskName] = undefined;
  // },
  addEvent: function(ev){

    // console.log('adding event', ev);
    events.push(ev);
  },
  eventStart: function(ev){

    //  ev should have :
    //  type
    //  name
    //  fileName

    if(typeof ev.type !== 'string'){
      throw Error('event has no type');
    } else if(typeof ev.name !== 'string'){
      throw Error('event has no name');
    } if(typeof ev.fileName !== 'string'){
      throw Error('event has no fileName');
    }

    //  set the 'start' time
    ev.start = process.hrtime();
    //  set a unique id for this event
    ev.id = idThis(ev);

    //  store it in the buffer
    buffer[ev.id] = {
      ev: ev
    };

    return ev.id; // TODO : or return this for chaining?
  },
  eventEnd: function(id){


  },
  exportJson: function(dest, cb){

    var wrappedJson,
        wrappedJsonDest,
        json;

    json = JSON.stringify({
      events: events,
      timeZero: timeZero
    });

    if(typeof dest !== 'string'){
      dest = DEFAULT_DEST_PATH;
    }

    //  TODO : error handling
    fs.writeFile(dest, json);

    //  export a function wrapped json
    wrappedJsonDest = path.join('node_modules', 'gulp', 'metricsViz', 'metrics.json.js');
    // console.log(wrappedJsonDest);

    wrappedJson = '(function(){ window.gulp_metrics = '+json+'; })()';
    // console.log(wrappedJson);

    fs.writeFileSync(wrappedJsonDest, wrappedJson);

  }
  */

  gulpInst.metrics = metrics;

};
