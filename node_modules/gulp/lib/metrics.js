//  metrics.js
//
//  library focused on providing a metrics API
//  for the Gulp itself, and all the plugins/modules within it
//
module.exports = function(gulpInst) {

'use strict';

//--------------------
//  modules
var fs        = require('fs'),
    path      = require('path'),
    // vfs       = require('vinyl-fs'),
//--------------------
//  Constants
    DEFAULT_DEST_PATH = path.join( __dirname, '../metrics'), //  ??????
//--------------------
//  variables
    metrics,
    Session,
    gulpSession,
    EventList,
    metricEvent,
    events = [],
    buffer = {},
    timeZero = process.hrtime(),  //  timeZero for our lib ( when the lib was instantiated )
    fs_readFile,
    fs_writeFile,
    fs_createWriteStream,
    gulp_src,
    gulp_dest,
    idThis;
//--------------------

if(!fs.existsSync(DEFAULT_DEST_PATH)){
  // make dir if it doesn't exist
  fs.mkdirSync(DEFAULT_DEST_PATH);
}

// console.log('gulp', gulpInst);
// console.log('cwd', __dirname);
console.log('metrics.json path :', DEFAULT_DEST_PATH);

//-------------------------------------------------
//------------------ metrics API ------------------
//

EventList = function(){
  this.list = {};
  this.counter = 0;  //  set seed

  return this;
};

EventList.prototype.getSeed = function(){
  return this.counter += 1;
};

EventList.prototype.addEvent = function(ev){

  //  event should have:
  //  name 'string'
  //  type 'string'
  //  filePath 'string'

  ev.timestamp = process.hrtime();

  ev.id = this.getSeed();

  this.list[ev.id] = ev;

  return this;
};

EventList.prototype.getList = function(){
  return this.list;
};

//  constructor of a Session object
//  holds a gulp session which should be a parent task run
Session = function(name){

  this.name = name;

  // mark start time
  this.startTime = process.hrtime();

  this.end = function(){
    //  mark finish time
    this.finishTime = process.hrtime();
  }

  this.exportSession = function(){

  };

  var list = new EventList();
  this.getList = function(){ return list; };

  this.export = function(){

    fs.writeFileSync(
      path.join(DEFAULT_DEST_PATH, Date.now()+'-metrics-session-'+this.name+'.json'),
      JSON.stringify(list)
    );
  };

  return this;
};


/*
//------------------ fs ------------------
//  monkeypatch fs read and write file in
//  order to log metrics from them
//
//  keep references to the original functions
fs_readFile = fs.readFile;
fs_writeFile = fs.writeFile;
fs_createWriteStream = fs.createWriteStream;

//  hijack readFile
fs.readFile = function(filename, options, callback){

  var start,
      onDone;

  //  set the start time
  start = process.hrtime();

  onDone = function(){

    //  set the end time
    var end = process.hrtime();

    // //  add the event in the metrics
    // metrics.addEvent({
    //   filename: filename,
    //   name: filename,
    //   type: 'fileRead',
    //   start: start,
    //   end: end
    // });
  };

  if(callback === undefined){

    fs_readFile(filename, function(err, data){
      onDone();

      if(typeof options === 'function') {
        options.call(this, err, data);
      }
    });

  } else {

    fs_readFile(filename, options, function(err, data){

      onDone();
      callback.call(this, err, data);
    });
  }

};

fs.writeFile = function(filename, data, options, callback){

  var start,
      onDone;

  //  set the start time
  start = process.hrtime();

  console.log('fs.writeFile', start);

  onDone = function(){

    //  set the end time
    var end = process.hrtime();

    // //  add the event in the metrics
    // metrics.addEvent({
    //   filename: filename,
    //   name: filename,
    //   type: 'fileWrite',
    //   start: start,
    //   end: end
    // });
  };

  if(callback === undefined){

    fs_writeFile(filename, data, function(err){
      onDone();
      if(typeof options === 'function') {
        options.call(this, err);
      }
    });
  } else {

    fs_writeFile(filename, data, options, function(err){

      onDone();
      callback.call(this, err);
    });
  }
};

fs.createWriteStream = function(path, options){

  console.log('fs.createWriteStream', path);

  return fs_createWriteStream.call(this, path, options);
};
*/

//------------------ gulp ------------------
//  keep the original functions
gulp_src  = gulpInst.src;
gulp_dest = gulpInst.dest;

gulpInst.src = function(globs, options){

  //  set up a counter for identifying calls to this function
  if(gulpInst.src.counter === undefined){
    gulpInst.src.counter = 0;
  }

  var gulp_src_stream = gulp_src(globs, options);
  var id = 'gulp_src.' + gulpInst.src.counter;

  //  add event to gulpSession
  gulpSession
  .getList()
  .addEvent({
    type: 'gulp_src-start',
    name: globs,
    options: options,
    id: id
  });

  //  increment the counter
  gulpInst.src.counter += 1;

  gulp_src_stream
  .on('data', function(file){
    //  add event to gulpSession
    gulpSession
    .getList()
    .addEvent({
      type: 'gulp_src-data',
      name: file.path,
      id: id
    });
    // console.log('file.path', path.basename(file.path) )
  })
  .on('end', function(){
    //  add event to gulpSession
    gulpSession
    .getList()
    .addEvent({
      type: 'gulp_src-end',
      id: id
    });
    // console.log('end for globs', globs);
  });

  // console.log('gulp_src', id, globs);

  return gulp_src_stream;
};

gulpInst.dest = function(globs, options){

  //  set up a counter for identifying calls to this function
  if(gulpInst.dest.counter === undefined){
    gulpInst.dest.counter = 0;
  }

  // console.log('gulp_dest', globs);
  var gulp_dest_stream = gulp_dest(globs, options);
  var id = 'gulp_dest.' + gulpInst.dest.counter;

  //  increment the counter
  gulpInst.dest.counter += 1;

  //  add event to gulpSession
  gulpSession
  .getList()
  .addEvent({
    type: 'gulp_dest-start',
    name: globs,
    options: options,
    id: id
  });

  gulp_dest_stream
  .on('data', function(file){
    // console.log('file.path', path.basename(file.path) )
    //  add event to gulpSession
    gulpSession
    .getList()
    .addEvent({
      type: 'gulp_dest-data',
      name: file.path,
      id: id
    });
  })
  .on('end', function(){
    // console.log('end for globs', globs);
    //  add event to gulpSession
    gulpSession
    .getList()
    .addEvent({
      type: 'gulp_dest-end',
      id: id
    });
  });

  return gulp_dest_stream;
};

//------------------ end of monkeypatching ------------------

//  listen for task start/end events
gulpInst.on('task_start', function (e) {
  // console.log('task_start',e.task ,e.message);
  gulpSession
  .getList()
  .addEvent({
    type: 'task-start',
    name: e.task
  });
});

gulpInst.on('task_stop', function (e) {
  // console.log('task_stop',e.task ,e.message);
  gulpSession
  .getList()
  .addEvent({
    type: 'task-stop',
    name: e.task
  });
});


gulpInst.on('start', function (e) {
  //e.message -> 'seq: clean,default'

  gulpSession = new Session('gulp-session');
  gulpSession.message = e.message;
});

gulpInst.on('stop', function (e) {
  //  gulp(orchestrator) stopped
  // console.log('stop', e.message);
  gulpSession.export();
});

console.log('=========================== timeZero',timeZero);

idThis = function(ev){

  //  produce a unique id for this event
  return ev.type + '.' + ev.name + '.' + ev.start[0] + '-' + ev.start[1];
};


  gulpInst.metrics = metrics;

};
